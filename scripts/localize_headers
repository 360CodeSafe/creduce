#!/usr/bin/perl -w

use strict;
use File::Spec;
use File::Copy;
use File::Basename;
use File::Compare;
use Cwd;

# TODO might need to support __has_include_next, __has_include

sub usage() {
    print "usage: $0 [-debug] compiler 'compiler args' source-file\n";
    print "the file should not be in the cwd\n";
    print "the file will be assumed to be C++ unless it ends with .c\n";
    exit(-1);
}

my $debug = 0;
if ($ARGV[0] eq "-debug") {
    shift @ARGV;
    $debug = 1;
}

usage() unless scalar(@ARGV)==3;
my $COMP = $ARGV[0];
my $CFLAGS = $ARGV[1];
my $FILE = $ARGV[2];

# TODO bail if file is in cwd

my $EXT;
my $CPP;
if ($FILE =~ /\.c$/) {
    $EXT = ".c";
    $CPP = "";
    print "looks like '$FILE' is C code\n";
} else {
    $EXT = ".cpp";
    $CPP = "-x c++";
    print "looks like '$FILE' is C++ code (if not you'll need to edit this script)\n";
}

# localize_headers clang -O2 ../hello.c

#my $FILE = "stl.cpp";
#my $COMP = "g++";
#my $CPP = "-x c++";
#my $CFLAGS = "-D__FC_MACHDEP_X86_32 -std=c++11 -I /home/regehr/tis-install/share/frama-c/frama-clang/libc++ -I /home/regehr/tis-install/share/frama-c/libc -I /home/regehr/tis-install/share/frama-c";
#my $EXT = ".cpp";

#my $FILE = "../hello.cpp";
#my $COMP = "clang++";
#my $CPP = "-x c++";
#my $CFLAGS = "";
#my $EXT = ".cpp";

#my $FILE = "../hello.cpp";
#my $COMP = "g++";
#my $CPP = "-x c++";
#my $CFLAGS = "";
#my $EXT = ".cpp";

#my $FILE = "../crypto/dso/dso_dl.c";
#my $COMP = "clang";
#my $CPP = "";
#my $CFLAGS = "-O3 -I../crypto/ -I../ -I../crypto/modes -I../crypto/asn1 -I../crypto/evp -I../include -m64";
#my $EXT = ".c";

my @exts = (".c", ".cpp");

sub runit ($) {
    my $cmd = shift;
    print "[ $cmd ]\n";
    die if ((system "$cmd") == -1);
    my $exit_value  = $? >> 8;
    return $exit_value;
}

my @includes;
my %deps;
my $srcfile_copy;

# get the include path
open INF, "echo | $COMP $CFLAGS -v $CPP -E - 2>&1 |" or die;
my $go = 0;
print "compiler search path:\n";
while (my $line = <INF>) {
    chomp $line;
    if ($line eq "#include <...> search starts here:") {
	$go = 1;
	next;
    }
    if ($line eq "End of search list.") {
	$go = 0;
	next;
    }
    if ($go) {
	$line =~ s/^\s*//;
	$line =~ s/\s*$//;
	my $p = Cwd::realpath($line);
	push @includes, $p;
	print "  $p\n";
	next;
    }
}
close INF;

# get the list of dependencies
open INF2, "$COMP $CFLAGS -c -w $CPP $FILE -M |" or die;
my $base = basename($FILE, @exts);
open OF, ">orig_deps.txt" or die;
while (my $f = <INF2>) {
    chomp $f;
    $f =~ s/$base\.o://g;
    $f =~ s/^\s*//;
    $f =~ s/\s*\\\s*//g;
    my @l = split /\s+/, $f;
    foreach my $g (@l) {
	print OF "$g ";
	# assume the actual src file is the first dependency
	if (!defined($srcfile_copy)) {
	    $srcfile_copy = basename($g);
	}
	$deps{Cwd::realpath($g)} = 1;
    }
}
close INF2;
close OF;

my %map;
my %rmap;

sub process($$$$) {
    (my $file, my $lref, my $next, my $line) = @_;
    my @list = @{$lref};

    print OUTF "# 0 // original line: \"$line\"\n" if $debug;

    print "looking for next after $next\n" if $next ne "";
    
    my $found = 0;
    my $path;
    foreach my $dir (@list) {
	$path = File::Spec->catfile($dir, $file);
	if (-e $path) {
	    if ($next ne "" && $path eq $next) {
		$next = "";
	    } else {
		$found = 1;
		last;
	    }
	}
    }
    # since we're not actually preprocessing, but rather going through
    # each header file renaming include files, it is natural that
    # we'll run into some files that don't exist on this system --
    # this is no problem but we want to trigger an error if such a
    # file ends up being needed after all
    if ($found) {
	if (exists $map{$path}) {
	    my $f = $map{$path};
	    print OUTF "#include \"$f\"";
	    print OUTF " // $path" if $debug;
	    print OUTF "\n";
	} else {
	    # whoops this file wasn't listed as a dependency but what
	    # the heck let's include it anyway -- this case gets hit
	    # when there are symlinks under /usr/include
	    my $f = Cwd::realpath($path);
	    my($justf, $dir) = fileparse($f);
	    print OUTF "#include \"$justf\"";
	    print OUTF " // backup plan for $f" if $debug;
	    print OUTF "\n";
	}
    } else {
	print "not found '$file'\n";
	print OUTF "#error localize_headers should not have tried to include $file $path\n";
    }
}

# make a local copy of a file with its include paths munged to refer
# to other copies -- when this is finished there should be no includes
# outside of the cwd
sub rewrite($$) {
    (my $absfile, my $target) = @_;
    open INF, "<$absfile" or die;
    open OUTF, ">$target" or die;
    my $n = 0;
    my($fnxxx, $dir, $suffixxx) = fileparse($absfile);
    my @dotincludes = @includes;
    unshift @dotincludes, $dir;
    while (my $line = <INF>) {
	chomp $line;
	$n++;
	if ($line =~ /^(\s*)#\s*include\s+\"(.*?)\"(.*)$/) {
	    process($2, \@dotincludes, "", $line);
	    next;
	}
	if ($line =~ /^(\s*)#\s*include\s+\<(.*?)\>(.*)$/) {
	    process($2, \@includes, "", $line);
	    next;
	}
	if ($line =~ /^(\s*)#\s*include_next\s+\<(.*?)\>(.*)$/) {
	    process($2, \@includes, $absfile, $line);
	    next;
	}
	print OUTF $line."\n";
    }
    close INF;
    close OUTF;
}

foreach my $dep (sort keys %deps) {
    my($file, $dirs, $suffix) = fileparse($dep);

    my $s1 = scalar(keys %map);
    my $s2 = scalar(keys %rmap);

    my $new = $file;
    my $count = 0;
    my $newnew = $new;
    while (exists($rmap{$newnew})) {
	$count++;
	$newnew = $new."_".$count;
    }
    $map{$dep} = $newnew;
    $rmap{$newnew} = $dep;

    die unless ($s1 < scalar(keys %map));
    die unless ($s2 < scalar(keys %rmap));
}

# copy over all dependencies
my $all_deps = "";
my $n = 0;
foreach my $dep (sort keys %deps) {
    rewrite($dep, $map{$dep});
    $all_deps .= "$map{$dep} ";
    $n++;
}

print "\'files_to_reduce.txt\' contains a list of all files copied to this dir\n";

open OUTF, ">files_to_reduce.txt" or die;
print OUTF "$all_deps\n";
close OUTF;

my $res;

$res = runit ("$COMP $CFLAGS -E $FILE > out1$EXT");
die unless $res == 0;
runit ("grep -v '^# ' out1$EXT | grep -v '^\\s*\$' > out1strip$EXT");

$res = runit ("$COMP $CFLAGS -E $srcfile_copy > out2$EXT");
die unless $res == 0;
runit ("grep -v '^# ' out2$EXT | grep -v '^\\s*\$' > out2strip$EXT");

print "\n";
print "original src file, preprocessed, is in out1$EXT, stripped of # lines as out1strip$EXT\n";
print "transformed src file, preprocessed, is in out2$EXT, stripped of # lines as out2strip$EXT\n";

print "\n";

if (compare("out1strip$EXT", "out2strip$EXT") == 0) {
    print "the stripped files are the same, which means this script might well have worked\n";
} else {
    print "the stripped files are different -- this script might have worked, but please\n";
    print "inspect the diffs manually\n";
}

print "\nreduce like this:\n";
print "     creduce interestingness_test `cat files_to_reduce.txt`\n\n";
