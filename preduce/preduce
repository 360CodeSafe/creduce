#!/usr/bin/perl
## -*- mode: Perl -*-
##
## Copyright (c) 2012 The University of Utah
## All rights reserved.
##
## This file is distributed under the University of Illinois Open Source
## License.  See the file COPYING for details.

######################################################################
#
# This is a generic Delta debugger that is parameterized by an
# interestingness test implemented as a shell script and a collection
# of transformation operators implemented as Perl modules.
#
####################################################################

use strict;
use warnings;

use FindBin;
use lib $FindBin::Bin, '/usr/local/share/creduce/perl';
use Exporter::Lite;
use File::Basename;
use File::Which;
use POSIX;
use Regexp::Common;

######################################################################

my $VERBOSE = 1;

# if set, ensure the delta test succeeds before starting each pass
my $SANITY = 0;

# if set, show a nice ascii spinner that tells us how quickly failing
# delta tests are happening
my $SPINNER = 0;

# if set, show what each transformation did
my $DIFFS = 0;

# slow -- but may detect non-deterministic test and bugs in cache
# logic
my $PARANOID = 0;

# save all variants
my $SAVE_COPIES = 0;

# if set, cache results (recommended)
my $CACHE = 1;

######################################################################

my $OK = 999999;
my $STOP = 111333;

my $orig_file_size;

sub print_pct ($) {
    (my $l) = @_;
    my $pct = 100 - ($l*100.0/$orig_file_size);
    printf "(%.1f %%, $l bytes)\n", $pct;
}

# these are set at startup time and never change
my $cfile;
my $test;
my $trial_num = 0;   

my $cfile_base;
my $cfile_bak;
my $cfile_orig;

sub runit ($) {
    (my $cmd) = @_;
    if ((system "$cmd") != 0) {
        my $res = $? >> 8;
        if ($res == 255) {
            return -1;
        }
        else {
            return -2;
        }
    }
    return ($? >> 8);
}

sub run_test () {
    my $res = runit "$test $cfile >/dev/null 2>&1";
    return ($res == 0);
}

my $good_cnt = 0;
my $bad_cnt = 0;
my $pass_num = 0;
my $old_size = 1000000000;

sub sanity_check () {
    print "sanity check... " if $VERBOSE;
    my $res = run_test ();
    if (!$res) {
	die "test (and sanity check) fails";
    }
    print "successful\n" if $VERBOSE;
}

my %cache = ();
my $cache_hits = 0;
my $test_cnt = 0;

my $cur_key = 0;
sub spinner() {
    my @chars = ("-", "\\", "|", "/");
    my $backsp = "\b";
    if ($cur_key == @chars) {
	$cur_key = 0;
    }
    print $backsp . $chars[$cur_key];
    $cur_key++;
}

sub read_file ($) {
    (my $cfile) = @_;
    open INF, "<$cfile" or die;
    my $prog = "";
    while (my $line = <INF>) {
	$prog .= $line;
    }
    close INF;
    if (substr($prog, 0, 1) ne " ") {
	$prog = " $prog";
    }
    if (substr ($prog, -1, 1) ne " ") {
	$prog = "$prog ";
    }
    return $prog;
}

sub write_file ($$) {
    (my $cfile, my $prog) = @_;
    open OUTF, ">$cfile" or die;
    print OUTF $prog;
    close OUTF;
}

# global invariant: the delta test always succeeds for $cfile_bak

sub delta_test ($$) {
    (my $arg, my $state) = @_;
    my $prog = read_file($cfile);
    my $len = length ($prog);

    print "[$pass_num lines :: $arg s:$good_cnt f:$bad_cnt] " 
	if $VERBOSE;

    if ($SPINNER) {
	spinner();
    }

    my $result;
    if ($CACHE) {
	$result = $cache{$len}{$prog};
    }

    if (defined($result)) {
	$cache_hits++;
    } else {    
	$result = run_test ();
	if ($CACHE) {
	    $cache{$len}{$prog} = $result;
	}
    }

    if ($PARANOID) {
	for (my $i=0; $i<5; $i++) {
	    my $result2 = run_test ();
	    die "paranoid failure" unless ($result == $result2);
	}
    }

    $test_cnt++;
    my $ret;
    
    if ($result) {
	print "\b" if $SPINNER;
	if ($SAVE_COPIES) {
	    my $FN = "${cfile_base}-paranoid-${test_cnt}-good";
	    print "saving paranoid file $FN\n" if $VERBOSE;
	    system "cp $cfile $FN";	 
	}
	print "success " if $VERBOSE;
	print_pct(-s $cfile);
	system "cp $cfile $cfile_bak";
	$good_cnt++;
	my $size = length ($prog);
	if ($CACHE && ($size < $old_size)) {
	    foreach my $k (keys %cache) {
		if ($k > ($size + 5000)) {
		    $cache{$k} = ();
		}
	    }
	}
	$old_size = $size;
	$ret = 1;
    } else {
	print "\b" if $SPINNER;
	if ($SAVE_COPIES) {
	    my $FN = "$cfile-paranoid-${test_cnt}-bad";
	    print "saving paranoid file $FN\n" if $VERBOSE;
	    system "cp $cfile $FN";	 
	}
	print "failure\n" if $VERBOSE;
	system "cp $cfile_bak $cfile";
	$bad_cnt++;
	$ret = 0;
    }

    return $ret;
}

sub count_lines ($) {
    (my $cfile) = @_;
    open INF, "<$cfile" or die;
    my $n=0;
    $n++ while (<INF>);
    close INF;
    return $n;
}

sub new ($$) {
    (my $cfile, my $arg) = @_;
    my %sh;
    $sh{"blanks"} = 1;
    return \%sh;
}

sub advance ($$$) {
    (my $cfile, my $which, my $state) = @_;
    my %sh = %{$state};

    return \%sh if defined($sh{"start"});
    $sh{"index"} += $sh{"chunk"};
    my $foo = $sh{"index"};
    # print "advanced index to $foo\n";
    return \%sh;
}

sub round ($) {
    (my $n) = @_;
    return int ($n+0.5);
}

sub transform ($$$) {
    (my $cfile, my $arg, my $state) = @_;
    my %sh = %{$state};

    if (defined $sh{"blanks"}) {
	delete $sh{"blanks"};
	$sh{"prep"} = 1;
	open INF, "<$cfile" or die;
	my $tmpfile = POSIX::tmpnam();
	open OUTF, ">$tmpfile" or die;
	while (my $line = <INF>) {
	    next if ($line =~ /^\s*$/);
	    print OUTF $line;
	}
	close INF;
	close OUTF;    
	system "mv $tmpfile $cfile";
	return ($OK, \%sh);
    }

    if (defined $sh{"prep"}) {
	delete $sh{"prep"};
	$sh{"flatten"} = 1;
	open INF, "<$cfile" or die;
	my $tmpfile = POSIX::tmpnam();
	open OUTF, ">$tmpfile" or die;
	while (my $line = <INF>) {
	    next if ($line =~ /^#/);
	    print OUTF $line;
	}
	close INF;
	close OUTF;    
	system "mv $tmpfile $cfile";
	return ($OK, \%sh);
    }

    if (defined $sh{"flatten"}) {
	delete $sh{"flatten"};
	$sh{"start"} = 1;
	my $tmpfile = POSIX::tmpnam();
	system "topformflat $arg < $cfile > $tmpfile";
	system "mv $tmpfile $cfile";	
	return ($OK, \%sh);
    }

    if (defined($sh{"start"})) {
	delete $sh{"start"};
	my $chunk = count_lines($cfile);
	$sh{"chunk"} = $chunk;
	print "initial granularity = $chunk\n" if $VERBOSE;
	$sh{"index"} = 0;
    }

  AGAIN:
    my $n=0;
    my $did_something=0;
    my $did_something_real=0;
    my $tmpfile = POSIX::tmpnam();
    open INF, "<$cfile" or die;
    open OUTF, ">$tmpfile" or die;
    while (my $line = <INF>) {
	if ($n >= ($sh{"index"} + $sh{"chunk"}) ||
	    $n < $sh{"index"}) {
	    print OUTF $line;
	} else {
	    print OUTF "\n";
	    $did_something++;
	    if (!($line =~ /^$/)) {
		$did_something_real++;
	    }
	}
	$n++;
    }
    close INF;
    close OUTF;
    
    if ($did_something) {
	my $newsh = advance ($cfile, $arg, \%sh);
	%sh = %{$newsh};
	if (!$did_something_real) {
	    print "skipping over blanks\n" if $VERBOSE;
	    goto AGAIN;
	}
	system "mv $tmpfile $cfile";
    } else {
	system "rm $tmpfile";
	return ($STOP, \%sh) if ($sh{"chunk"} == 1);
	my $newchunk = round ($sh{"chunk"} / 2.0);
	$sh{"chunk"} = $newchunk;
	print "granularity = $newchunk\n" if $VERBOSE;
	$sh{"index"} = 0;
    }

    # print "chunk= ".$sh{"chunk"}.", index= ".$sh{"index"}.", did_something= ".$did_something."\n";

    return ($OK, \%sh);
}

sub delta_pass ($) {
    (my $delta_arg) = @_;    

    if ($SANITY) {
	sanity_check();
    }

    my $state = new ($cfile,$delta_arg);

    while (1) {
	(my $res, $state) = transform ($cfile,$delta_arg,$state);
	return if ($res == $STOP);
	die unless ($res == $OK);
	system "diff $cfile_bak $cfile" if $DIFFS;
	delta_test ($delta_arg,$state);
    }
}

sub usage() {
    print "usage:reduce test_script.sh file.c\n";
    die;
}

############################### main #################################

print "\n" if $VERBOSE;

$test = shift @ARGV;
usage unless defined($test);
if (!(-e $test)) {
    print "test script '$test' not found\n";
    usage();
}
if (!(-f $test)) {
    print "test script '$test' is not a plain file\n";
    usage();
}
if (!(-r $test)) {
    print "test script '$test' is not readable\n";
    usage();
}
if (!(-x $test)) {
    print "test script '$test' is not executable\n";
    usage();
}

$cfile = shift @ARGV;
usage unless defined($cfile);
if (!(-e $cfile)) {
    print "'$cfile' file not found\n";
    usage();
}
if (!(-f $cfile)) {
    print "'$cfile' is not a plain file\n";
    usage();
}
if (!(-r $cfile)) {
    print "'$cfile' is not readable\n";
    usage();
}
if (!(-w $cfile)) {
    print "'$cfile' is not writable\n";
    usage();
}

# Put scratch files ($cfile_bak, $cfile_orig) in the current working directory.
$cfile_base = fileparse($cfile);
$cfile_bak  = "$cfile_base.bak";
$cfile_orig = "$cfile_base.orig";

system "cp $cfile $cfile_orig";
system "cp $cfile $cfile_bak";

my $file_size = -s $cfile;
$orig_file_size = $file_size;

# unconditionally do this just once since otherwise output is
# confusing when the initial test fails
sanity_check();

# iterate to global fixpoint
$file_size = -s $cfile;

delta_pass (0);
delta_pass (1);
delta_pass (2);
delta_pass (10);

print "===================== done ====================\n";

print "\n";

print "reduced test case:\n\n";
system "cat $cfile";

######################################################################
